# -*- coding: utf-8 -*-
"""Orientaçao a Objeto.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dDBLHNxIqcTQZqR2dzi6Z7RUDKl03vwt

#Orientação a Objeto 

Programação orientada a objetos (POO, ou OOP segundo as suas siglas em inglês) é um paradigma de programação baseado no conceito de "objetos", que podem conter dados na forma de campos, também conhecidos como atributos, e códigos, na forma de procedimentos, também conhecidos como métodos. Uma característica de objetos é que um procedimento de objeto pode acessar, e geralmente modificar, os campos de dados do objeto com o qual eles estão associados (objetos possuem uma noção de "this" (este) ou "self" (próprio)).

Em POO, programas de computadores são projetados por meio da composição de objetos que interagem com outros.[1][2] Há uma diversidade significante de linguagens de POO, mas as mais populares são aquelas baseadas em classes, significando que objetos são instâncias de classes, que, normalmente, também determinam seu tipo.

Fonte: Disponivel em<https://pt.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_orientada_a_objetos> Acessado em <13/06/2022>

Basecamente tentaremos abstrair o mundo real em objetos, os separando e os inteligando dependendo de sua função so sistema, o qual ele esta inserido no mundo real.

- Uma pessoa:

Como podemos representar uma pessoa?

Depende, de qual será a utilização desse <b>Molde</b> de pessoa. 

Imaginemos que será para um cadastro em uma sistema de educação, neste caso o que seria relevante?

- nome
- data_nascimento
- rg
- tel


Digamos que com esses dados podemos realizar todos as opeçãoes necessarias em nosso sistema. 

Obs.: Cada sistema possui suas regras.
"""



#Criamos um classe pessoa
class Pessoa:
  pass

# vamos instanciar o objeto 

p1=Pessoa()
#Atribuindo um atributo a somente uma instancia

p1.nome="Rogério"

print(p1.nome)

# Caso você queira invocar o atributo nome no p2 vai lançar um erro, pois atributo não da classe
#print(p2.nome)

#devemos tornar esse atributo do molde em geral

#Criamos uma classe pessoa
class Pessoa:

  def __init__(self, nome, ano_nascimento):
      self.nome=nome
      self.ano_nascimento=ano_nascimento

p1= Pessoa("rogério",1983)

print(p1.ano_nascimento)

import datetime as dt

data=dt.date.today()

print(data.year)

#Usando um construtor
p1=Pessoa("rogerio")
p2=Pessoa("Carlos")
#Ambos agora possuem um atributo nome
print(p1.nome)
print(p2.nome)

from datetime import date 

#Metodos 
# São como Funções que a classe possui para realizar tarefas.

#Criamos uma classe pessoa
class Pessoa:
  #Aqui atribuimos todos os atributos que queremos que a pessoa entre quando criar um objeto do tipo pessoa, 
  #para isso definimos no contrutor 
  def __init__(self, nome, data_nascimento, rg, tel):
      self.nome=nome
      self.data_nascimento=data_nascimento
      self.rg=rg
      self.tel=tel

  #metodo que calcula a idade

  def getIdade(self):
     ano_atual= date.today().year
     return ano_atual-self.data_nascimento

#Usando um construtor
p1=Pessoa("rogerio",1983,"123456789","1196969696")

#Ambos agora possuem um atributo nome
print(p1.nome)
p1.getIdade()

class cliente:

  def __init__(self, nome, data_nas, tel, cpf, end, email):
    self.nome= nome
    self.data_nas=data_nas
    self.tel= tel
    self.cpf=cpf
    self.end=end
    self.email=email



#Atributo da classe  não do objeto 
from datetime import date 
class Pessoa:
  ano_atual= date.today().year
  #Aqui atribuimos todos os atributos que queremos que a pessoa entre quando criar um objeto do tipo pessoa, 
  #para isso definimos no contrutor 
  def __init__(self, nome, data_nascimento, rg, tel):
      self.nome=nome
      self.nome=nome
      self.data_nascimento=data_nascimento
      self.rg=rg
      self.tel=tel

  #metodo de instancia que calcula a idade
  def getIdade(self):
     
     return self.ano_atual-self.data_nascimento

#Usando um construtor
p1=Pessoa("rogerio",1983,"123456789","1196969696")

#Ambos agora possuem um atributo nome
print(p1.nome)
p1.getIdade()

#Poderiamos Validar as entradas dos atributos antes de salva-los para que a pessoa digitar corretamente

"""##Metodos de Classe"""

from datetime import date 
class Pessoa:
  ano_atual= date.today().year
  id=0;
  #Aqui atribuimos todos os atributos que queremos que a pessoa entre quando criar um objeto do tipo pessoa, 
  #para isso definimos no contrutor 
  def __init__(self, nome, data_nascimento, rg, tel):
      self.nome=nome
      self.nome=nome
      self.data_nascimento=data_nascimento
      self.rg=rg
      self.tel=tel
      self.id_usuario=self.id+1
      Pessoa.addID()


  #metodo de instancia que calcula a idade
  def getIdade(self):
     return self.ano_atual-self.data_nascimento


  #Metodo de classe 
  @classmethod    
  def addID(cls):
    cls.id+=1
    return  cls.id

p=Pessoa("rogerio",1983,"123456789","1196969696")

p1=Pessoa("rogerio",1983,"123456789","1196969696")
p2=Pessoa("Carlos",1999,"34567889","000000000")
p3=Pessoa("maria",2020,"5555555","1111111111")

print(p1.id_usuario)
print(p2.id_usuario)
print(p3.id_usuario)
print(p2.id_usuario)

print(Pessoa.id)

"""## Métodos estáticos """

from datetime import date 
import random as rd
class Pessoa:
  ano_atual= date.today().year
  id=0;
  #Aqui atribuimos todos os atributos que queremos que a pessoa entre quando criar um objeto do tipo pessoa, 
  #para isso definimos no contrutor 
  def __init__(self, nome, data_nascimento, rg, tel):
      self.nome=nome
      self.nome=nome
      self.data_nascimento=data_nascimento
      self.rg=rg
      self.tel=tel
      self.id_usuario=self.id+1
      Pessoa.addID()


  #metodo de instancia que calcula a idade
  def getIdade(self):
     return self.ano_atual-self.data_nascimento


  #Metodo de classe 
  @classmethod    
  def addID(cls):
    cls.id+=1
    return  cls.id

  #Metodo estatico 
  @staticmethod
  def geraID():
    rand=rd.randint(10000,19999)
    return int(rand)

p1=Pessoa("rogerio",1983,"123456789","1196969696")
p2=Pessoa("Carlos",1999,"34567889","000000000")
p3=Pessoa("maria",2020,"5555555","1111111111")

print(p1.id_usuario)
print(p2.id_usuario)
print(p3.id_usuario)
print(p1.geraID())
print(p2.geraID())

"""## @property - Getters e Setters 

Metodos para criar acesso aos nossos atributos da instancia 
"""

class Produto:
  def __init__(self, nome, preco):
      self.nome=nome
      self.preco=preco

  def desconto(self, valor):
    self.preco= self.preco-((self.preco*valor)/100)

  @property
  def preco(self):
    return self._preco


  @preco.setter
  def preco(self,valor):
    if isinstance(valor, str):
      valor= float(valor.replace("R$",""))
    self._preco=valor



  @property
  def nome(self):
    return self._nome

  @nome.setter
  def nome(self, valor):
     self._nome=valor.title()

prod=Produto("rogerio","R$67")

print(prod.nome) # repare que o nome esta com title , inicial maiuscula
print(prod.preco)

"""##Atributos de Classe"""

class Teste:
  variavel=123 

  def __init__(self):
     self.variavel=222

t= Teste()
t2=Teste()

print(t.variavel)
print(t2.variavel)
print(Teste.variavel)# atributo Global

"""##Encapsulamento

Encapsulamento é um conceito de programação orientada a objetos que liga os atributos e métodos,sem que haja interferência direta entre eles. Isto é, uma classe pode utilizar recursos de outra classe sem a necessidade de conhecer o código fonte destes recursos, mesmo reimplementando-os. As entradas, os processamentos e as saídas de um objeto não influenciam os dos outros, pois os seus relacionamentos são apenas referenciados
"""

dicionario={"Nome":"Rogerio", "idade": 28, "tel":"1147427293"}

dicionario["idade"]

dicionario.items()

lista=[12,44,55]

lista[0]=100
lista[0]

tupla=(12,44,55)

tupla[0]=122

# Public protected=_ private = __

class BaseDados:

  def __init__(self):
      self.__dados={}


  def incerirClientes(self, id, value):
    if "clientes" not in self.__dados:
      self.__dados["clientes"]={id:value}
    else:
      self.__dados["clientes"].update({id:value})

  
  def listaClientes(self):
    for id, nome in self.__dados["clientes"].items():
       print(f"ID: {id} Nome {nome}") 


  def apagaCliente(self, id):
    del self.__dados["clientes"][id]

bd= BaseDados()

bd.incerirClientes(1,"Carlos")
bd.incerirClientes(2,"Maria")
bd.incerirClientes(3,"Pedro")

bd.listaClientes()

bd.apagaCliente(2)

bd.listaClientes()

# Para acessar um atributo private você deve:
# Obs.: Evite acesso a atributos que foram declarados como private
# para acessar esse atributo diretamente você pode gerar um getter

print(bd._BaseDados__dados)

"""##Associação """

class Escritor:
  def __init__(self, nome):
      self.__nome=nome
      self.__ferramenta=None

  #Criando um getter
  @property
  def nome(self):
    return self.__nome


  @property
  def ferramenta(self):
    return self.__ferramenta

  @ferramenta.setter
  def ferramenta(self, equipamento):
    self.__ferramenta=equipamento

class Caneta:

  def __init__(self, marca):
    self.__marca=marca

  @property
  def marca(self):
    return self.__marca

  def escrever(self):
    print("A caneta esta escrevendo")

class Maquina:
  def escrever(self):
    print("A maquina esta escrevendo")

"""Imageine que colocamos as duas classes em um modulo chamado <b>classes</b>
Se estivessemos trabalhando com modulos, teriamos de importar cada classe para rodar em nossa <b>main</b>

- <i> from classes import Escritor</i>

- <i> from classes import Caneta</i>

- <i> from classes import Maquina</i>

Porém vamos fazer diretamente no colab

"""

escritor= Escritor("Carlos")
caneta= Caneta("Castell")
maquina= Maquina()

escritor.ferramenta=caneta
escritor.ferramenta.escrever()
escritor.ferramenta=maquina
escritor.ferramenta.escrever()

"""##**Agregação**

O tipo de associação agregação pode ser classificada basicamente de duas formas: agregação de composição e agregação compartilhada (ou reflexiva).

Agregações
Esses tipos de relações são chamados assim porque agregam valor para o objeto relacionado. Esse é um tipo especializado de associação que nos permite encarar a relação entre os objetos como: Todo/Parte.

Todo/Parte significa que um dos lados da associação (um classe) é chamado de Todo e o outro lado é chamado de Parte, já que a parte nos permite pensar que: A Parte está contida no Todo.


**Agregação** (ou agregação compartilhada)
Essa também é uma relação todo/parte, porém, nesse caso dizemos que a parte é compartilhada por outros (por isso agregação compartilhada). Isso significa que a parte de um tipo A está contida em um tipo B, quando esse tem relação de agregação entre eles, porém, essa mesma parte A não existe somente para compor B, essa parte pode agregar outros tipos.
"""

class CarrinhoCompras:
  def __init__(self):
    self.produtos=[]

   

  def incerirProdutos(self, produto):
    self.produtos.append(produto)

  def listarProdutos(self):
    for elemento in self.produtos:
      print("Item: "+elemento.nome, " R$: ", elemento.valor)

  def total(self):
    soma=0
    for produto in self.produtos:
      soma+=produto.valor
    return soma




class Produto:

  def __init__(self, nome, valor):
      self.__nome=nome
      self.__valor=valor

  @property
  def nome(self):
    return self.__nome

  @nome.setter
  def nome(self, nome):
    self.__nome=nome

  @property
  def valor(self):
    return self.__valor

  @valor.setter
  def valor(self, valor):
    self.__valor=valor

carrinho= CarrinhoCompras()

#produtos
produto1= Produto("Arroz", 26.56)
produto2= Produto("Feijão", 8.70)
produto3= Produto("Macarrão", 4.33)
produto4= Produto("Leite", 5.50)

#agregando o produto ao carrinho

carrinho.incerirProdutos(produto1)
carrinho.incerirProdutos(produto2)
carrinho.incerirProdutos(produto3)
carrinho.incerirProdutos(produto4)

carrinho.listarProdutos()

print(round(carrinho.total(),3))

"""##**Composição** (ou agregação de composição)


Toda vez que dizemos que a relação entre duas classe é de composição estamos dizendo que uma dessas classe (a Parte) está contida na outra (o Todo) e a parte não vive/não existe sem o todo.

Sendo assim, toda vez que destruirmos o todo, a parte que é única e exclusiva do todo se vai junto. Por esse motivo que algum dizem que: a parte está contida no todo. Quando se joga o todo fora, a parte estava dentro e se vai junto.


"""

# Classe Endereço  pertence a um Cliente

class Endereco:

  def  __init__(self, cidade, estado):
    self.cidade=cidade
    self.estado=estado

  def __del__(self):
    print(f"Fechando a classe endereco : {self.cidade}")


#classe cliente possui um endereço
class Cliente:

  def __init__(self, nome, idade):
    self.nome=nome
    self.idade=idade
    self.enderecos=[]


  def inserirEndereco(self,cidade, estado ):
    self.enderecos.append(Endereco(cidade,estado))

  
  def listarEndereco(self):
    for endereco in self.enderecos:
      print(f" Cidade: {endereco.cidade} Estado: {endereco.estado}")

  def __del__(self):
    print(f"Fechando a classe Cliente : {self.nome}")

cliente1= Cliente("Carlos", 34)

cliente1.inserirEndereco("Tatuapé", "São Paulo")
cliente1.inserirEndereco("Salvador", "Bahia")
print(cliente1.nome)
cliente1.listarEndereco()
#del cliente1
print("=="*30)

cliente2= Cliente("Maria", 65)

cliente2.inserirEndereco("Belo Horizonte ", "Minas Gerais")
print(cliente2.nome)
cliente2.listarEndereco()
#del cliente2
print("=="*30)

"""Repare que a classe Endereço esta ligada a classe Cliente, quando a principal e deletado altomaticamente a outra também é, pois ela existe ligada a principal.

##Herança Simples

Resumo:

- Associação  - Usa
- Agregação - Tem
- Composição - é Dono 
- Herença - É
"""

class Pessoa:

  def __init__(self, nome, idade):
    self.nome=nome
    self.idade=idade
    self.nomeClasse= self.__class__.__name__

  def falar(self):
    print(f"{self.nomeClasse} esta falando")


# as Duas classes que se segui são filhas de Pessoa, herdam tudo que pessoa tem 
class Aluno(Pessoa):
  pass


class Professor(Pessoa):
  pass

aluno= Aluno("Carlos", 34)
professor= Professor("José", 55)
aluno.falar()
professor.falar()

"""##Sobreposição de Membros"""

class Pessoa:

  def __init__(self, nome , idade):
    self.nome=nome
    self.idade=idade

  def falar(self):
    print(f" O {self.nome} esta falando em Pessoa")




class Cliente(Pessoa):
  pass
 


class ClienteVip(Cliente):
  #Sobre escrevendo o construtor
  def __init__(self, nome, idade, sobrenome):
      super().__init__(nome, idade)
      self.sobrenome=sobrenome

  #sobre escrevendo o metodo
  def falar(self):
     super().falar()
     print(f" O {self.nome} clienteVIp esta falando")

c=ClienteVip("Carlos",23,"rocha")
c.falar()

"""##Herança múltipla"""

class A:

  def falar(self):
    print("Falando em A")

class B(A):

  def falar(self):
    print("Falando em B")


class C(A):

  def falar(self):
    print("Falando em C")

# A herança dos metodos segui da esquerda para direta primeiro o metodo de C depois o de B
class D (C,B):
  pass

d = D()

d.falar()

"""##Mixins

É uma classe que define um conjunto de funções relacionadas a um tipo. Ou seja, uma forma de composição de objetos, onde as características dos componentes se misturam em um objeto composto, de modo que as propriedades de cada mistura se tornem propriedades do objeto composto.
"""

class Eletronico:
  def __init__(self,nome):
      self._nome=nome
      self._ligado=False

  def ligar(self):
    if not self._ligado:
      self._ligado=True
      print("Ligado com sucesso")
    else:
      print(" já esta Ligado")

      return

  def desligar(self):
    if self._ligado:
      print(f"{self._nome} desligado com Sucesso")
      self._ligado=False
    else:
      print(f"O {self._nome} já esta Desligado ")
      return

class LogMixin:

  @staticmethod
  def write(msg):
    with open("arquivo.txt","a+") as f:
      f.write(msg)
      f.write("\n")

  def log_info(self,msg):
    self.write(f"INFO {msg}")

  def log_error(self,msg):
    self.write(f"ERROR {msg}")

class SmartPhone(Eletronico, LogMixin):
  def __init__(self, nome):
      super().__init__(nome)
      self.conectado=False


  def conectar(self):
      if not self._ligado:
        error=f"O {self._nome} esta desligado"
        print(error)
        self.log_error(error)
        return
      else:
        if not self.conectado:
          info=f"O {self._nome} foi conectado com sucesso"
          self.conectado=True
        else:
          erro=f"{self._nome} já esta conectato"
          print(erro)
          self.log_error(erro)
          return

  def desconectar(self):
    if not self.conectado:
      error=f"{self._nome} não esta conectado"
      print(error)
      self.log_error(error)
      return
    info= f"{self._nome} foi desconectado com sucesso"
    self.log_info(info)
    self.conectado=False

phone=SmartPhone("Phonetalo")

phone.ligar()

print(phone.conectado)
phone.conectar()
phone.desconectar()
print(phone.conectado)
phone.desligar()
phone.conectar()

"""##Classes Abstratas 

É um tipo de classe especial que não pode ser instanciada, apenas herdada. Sendo assim, uma classe abstrata não pode ter um objeto criado a partir de sua instanciação. Essas classes são muito importantes quando não queremos criar um objeto a partir de uma classe “geral”, apenas de suas “subclasses”.

fonte: https://www.treinaweb.com.br/blog/classes-abstratas-vs-interfaces#:~:text=%C3%89%20um%20tipo%20de%20classe,apenas%20de%20suas%20%E2%80%9Csubclasses%E2%80%9D.
"""

#Precisamos importar uma biblioteca 
from abc import ABC, abstractmethod

class Conta(ABC): #classe abstrata ela tem que ter um metodo abstrato
  def __init__(self, agencia, conta, saldo):
    self._agencia=agencia
    self._conta=conta
    self._saldo=saldo
      
  @property
  def agencia(self):
    return self._agencia

  @property
  def conta(self):
    return self._conta

  @property
  def saldo(self):
    return self._saldo

  @agencia.setter
  def agencia(self,agencia):
    self._agencia=agencia

  @conta.setter
  def conta(self,conta):
    self._conta=conta
  
  @saldo.setter
  def saldo(self,valor):
    if isinstance(valor,(int,float)):
      self._saldo=valor
    else:
      raise ValueError(f"O {valor} não é uma informação numérica")

  def depositar(self,valor):
    if isinstance(valor,(int,float)):
      self._saldo+=valor
      self.detalhes()
    else:
      raise ValueError(f"O valor do desposito precisa ser numérico")

  def detalhes(self):
    print(f"Agencia: {self.agencia}", end=" ")
    print(f"Conta: {self.conta}", end=" ")
    print(f"Saldo: {self.saldo}")


  @abstractmethod   #Metodo abstrato
  def sacar(self, valor):
    pass

class ContaPoupanca(Conta):
  pass

  def sacar(self,valor):
    if isinstance(valor,(int, float)):
      if valor<=self.saldo:
        self.saldo-=valor
        self.detalhes()
      else:
        print("Valor em conta é insuficiente para sacar")
    else:
      raise ValueError(f"O valor à sacar precisa ser numérico")

cp=ContaPoupanca(1234,192309,1240.50)
print(cp.saldo)

cp.depositar(450)

cp.sacar(230)

class ContaCorrente(Conta):
  
  def __init__(self, agencia, conta, saldo, limite=100):
      super().__init__(agencia, conta, saldo)
      self._limite=limite

  @property
  def limite(self):
    return self._limite

  def addlimite(self):
      self.saldo+=self._limite
      print("Entrou no limite")
    
  def sacar(self,valor):
    if isinstance(valor,(int, float)):
      if valor<=(self.saldo):
        self.saldo-=valor
        self.detalhes()
      elif valor<(self.saldo+self._limite):
        self.addlimite()
        self.saldo-=valor
        self.detalhes()
    else:
      raise ValueError(f"O valor à sacar precisa ser numérico")

cc=ContaCorrente(1234,1111,2000.00)

cc.sacar(1900)

cc.sacar(100)

cc.sacar(50)

"""##Sobrecarga de Operadores

Os métodos especiais ou mágicos em Python são utilizados para que definir um comportamento específico para uma classe quando determinada operação for operada.

Por exemplo, existem situações onde você poderá definir um comportamento quando o objeto dessa classe for tratada como str ou ainda como float.

###  "\__str__"

É invocado quando o objeto é invocado como str.
"""

class MyClass(object):
  def __init__(self):
    pass

  def __str__(self): 
    return 'is my class'


obj = MyClass();

print("This " + str(obj))

"""### \__call__

É invocado quando o objeto é invocado como função.
"""

class MyClass(object):
    def __call__(self):
        return 'Hello World!'


obj = MyClass();

print(obj())

"""###\__init__

É utilizado para inicializar a classe.
"""

class Person(object):
    def __init__(self, name):
        self.name = name   


p = Person('Wallace');

print(p.name)

"""###\__float__
Quando você define esse método, sua classe passa a ter o comportamento determinado por ele quando houver uma tentativa de usar a instância dessa classe como o tipo float.


Os exemplos de \__str__ e \__float__ explicam  como usar  \__int__, \__bytes__, \__dict__, já que eles vão trabalhar  semelhantemente.
"""

class Numero(object):

    def __float__(self):
        return 2.2222



print(float(Numero()))

"""###Outros Operadores

- \__lt__: Menor que (less than)
- \__le__: Menor ou igual (less or equal)
- \__eq__: Igual (equals)
- \__ne__: Não igual (not equal)
- \__ge__: Maior ou igual (greather or equal)
- \__gt__: - Maior que (greather than)

Todos os métodos acima são invocados quando você utiliza uma expressão comparativa. Geralmente, eles recebem um parâmetro que deverá ser comparado com um valor da classe atual.

###\__eq__
"""

class Numero:
    def __init__(self, numero):
        self.numero = numero   

    def __eq__(self, a):
        return self.numero== a.numero


a = Numero(2)
b = Numero(2)

print(a == b)
print(b == a)

"""###\__add__
###\__lt__
###\__gt__

"""

class Quadrado:
  def __init__(self, x, y):
    self.x=x
    self.y=y


  def __add__(self,other):
    novo_x= self.x+other.x
    novo_y= self.y+other.y
    return novo_x, novo_y

  def area(self):
    return self.x+self.y

  def __lt__(self, other): #Compara dois objetos para definir se é menor
    return self.area()< other.area()

  def __gt__(self, other): #Compara dois objetos para definir se é maior
    return self.area()> other.area()


  

q1= Quadrado(2,5)
q2= Quadrado(3,3)

print(q1>q2)

"""##Métodos mágicos

link: https://rszalski.github.io/magicmethods/
"""

class A:
  #faz com o qual o objeto aja como uma função
  def __call__(self, *args, **kwds):
      return sum(args)


a=A()

print(a(12,2,3,4,56))

"""##Context Manager"""

with open("arquivo.txt", "w") as f:
  f.write("Escrevendo em um arquivo")

"""Podemos criar nosso proprio gerenciador de contexto"""

class Arquivo:
  def __init__(self, arquivo,modo):
    print("Abrindo arquivo")
    self.arquivo=open(arquivo, modo)

  def __enter__(self):
    print("Retornando arquivo")
    return self.arquivo

  def __exit__(self, exc_type,exc_val,exc_tb):
    print("fechando arquivo")
    self.arquivo.close()

with Arquivo("arquivo.txt", "w") as f:
  f.write("sei la")

#Gerenciador de contexto 2
from contextlib import contextmanager

@contextmanager
def abrir(arquivo,modo):
  try:
    arquivo=open(arquivo,modo)
    print("abrindo")
    yield arquivo
  finally:
    print("fechando")
    arquivo.close()

# o with chama os metodos __enter__ e __exit__ por baixo dos panos

with abrir("teste.txt","w") as f:
  f.write("Escrevendo linha 1\n")
  f.write("Escrevendo linha 2\n")
  f.write("Escrevendo linha 3\n")

"""##Metaclasses

Em orientação a objetos, uma metaclasse é uma classe cujas instâncias também são classes e não objetos no sentido tradicional. Assim como classes definem o comportamento de certos objetos, metaclasses definem o comportamento de certas classes e suas instâncias.
"""

class Meta(type):
  def __new__(mcs,name,bases,namespace):
    if name=="A":
      return type.__new__(mcs,name,bases,namespace)
    print(namespace)
    if 'b_fala' not in namespace:
      print(f"Você precisa criar o metodo b_fala em {name} ")
    else:
      if  not callable(namespace['b_fala']):
        print(f"b_fala precisa ser um metodo não atributo  em {name}")
    return type.__new__(mcs,name,bases,namespace)

class A(metaclass=Meta):
  def falar(self):
    self.b_fala()

class B(A):
  pass
  b_fala="sei la"
  #def b_fala(self):
    #print("oi")

class Meta(type):
  def __new__(mcs,name,bases,namespace):
    if name=="A":
      return type.__new__(mcs,name,bases,namespace)
    if "naoApagar" in namespace:
      del namespace["naoApagar"]

    return type.__new__(mcs,name,bases,namespace)



class A(metaclass=Meta):
  naoApagar=123
 

class B(A):
  naoApagar="subescrevi o conteudo"
  
# Com isso você pode impedir que subescrevam seus atributos e metodos em classes filhas 
b=B()
print(a.naoApagar)

"""##DocStrings

Documentação da classe e dos metodos
"""

class UmaLinha:
  """ Explicação da classe: Essa classe não faz nada  """
  def __init__(self):
    self.valor=0

  def funcao(self):
    pass

help(UmaLinha)

class VariasLinhas:
  """
  Documentação: O que a Classe faz.

  Autor: Rogério Sobral
  Versão:0.01.
  
  Essa classe não faz nada só atende a ao proposito educacional.
  Aqui você descreve o porque dessa classe.
  """
  def soma(self, x,y):
    """ Soma dois valores (x + y)
    :param x: number 1
    :type  x: int or float
    :param y: number 2
    :type  y: int or float
    :Return : Soma dos valores
    :rtype  : int or float 
    """
    return x+y

help(VariasLinhas)

"""## Typing"""

x:int=12 # declarando para quem for usar a variavel que tipo deve receber
print(x)

def funcao(x)-> int:  # descreve o type do valor que vai retornar
  return x


from typing import Union

def funcao2(x:float)->Union[int,float]:# descreve a possibilidade de mais de um type para retornar

  return x

"""##Dataclasses

O que são dataclasses? O módulo Dataclasses fornece um decorador e funções
para criar automaticamente métodos, como __init__(), __repr__(), __eq__ (etc)
em classes definidas pelo usuário.
Basicamente, dataclasses são syntax sugar para criar classes normais.
Foi originalmente descrito na PEP 557.
Adicionado na versão 3.7 do Python.
Leia a documentação: https://docs.python.org/pt-br/3/library/dataclasses.html

"""

from dataclasses import dataclass

@dataclass(eq=True)
class Pessoa :
  nome:str
  idade:int
  cpf:str

  def __post_init__(self):
     if not isinstance(self.nome,str):
         raise TypeError(f"{type(self.nome).__name__} é diferente de str em  {self}")

p1=Pessoa("Rogério",38,"1234567889")
p2=Pessoa("Carlos",22,"67889")
p3=Pessoa("Maria",19,"5555555555")
p4=Pessoa("123",38,"1234567889")

lista=[p1,p2,p3,p4]
print(p1==p2)
print(p1==p4)
sorted(lista, key=lambda idade: idade.idade, reverse=True)

"""##Enum"""

from enum import Enum, auto

class Direcoes(Enum):
  left= auto()
  right=auto()
  up=auto()
  down=auto()

def movimentacao(direcao):
  if not isinstance(direcao,Direcoes):
    raise ValueError("Não exites essa direção")
  return f"Moving {direcao.name}"



print(movimentacao(Direcoes.left))
print(movimentacao(Direcoes.right))
print(movimentacao(Direcoes.up))
print(movimentacao(Direcoes.down))

for direcao in Direcoes:
  print(direcao.name, direcao.value)

"""##Implementando um iterator"""

class MinhaLista:

  def __init__(self):
    self.__itens=[]
    self.index=0


  def add(self, value):
    self.__itens.append(value)

  def __getitem__(self,index):
    return self.__itens[index] 

  def __setitem__(self, index,value):
    if index>=len(self.__itens):
      self.__itens.append(value)
    self.__itens[index]=value 

  def __delitem__(self,index):
    if index<=len(self.__itens):
      del self.__itens[index]
      return
    raise IndexError("Index fora do tamanho da lista")

  def __iter__(self):
    return self

  def __next__(self):
    try:
      item=self.__itens[self.index]
      self.index+=1
      return item
    except IndexError:
      raise StopIteration

  def __str__(self):
    return f"{self.__class__.__name__} {self.__itens}"

from os import listxattr
lista=MinhaLista()

lista.add("Rogerio")
lista.add("Carcos")
lista.add("Pedro")

print(lista)

for valor in lista:
  print(valor)

print("---"*20)

print(lista[1])
print("---"*20)
lista[1]="Tony"
print(lista)
print("---"*20)

del lista[1]

print(lista)